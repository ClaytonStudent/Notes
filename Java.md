## JAVA 

### 1. 基础语法

#### 1. JAVA 与 C

java不适用指针，而是引用。提供自动的废料收集，不用为内存管理而担忧

java是纯面向对象语言，支持类之间单继承，接口之间多继承。支持类与接口之间的实现机制

#### 2. 抽象类与接口

**[抽象类**: 抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法，则称这个类为抽象类](https://www.cnblogs.com/dolphin0520/p/3811437.html)

**接口**:是一种极度抽象的类型，接口可理解为对象间相互通信的协议

#### 3. 修饰符

访问控制修饰符 default, public, protected, private

非访问控制修饰符 final(修饰常量), abstract, static, synchronized

#### 4. 数据类型

1. byte  8 bit -128 --- 127
2. short 16 bit -32768-32767
3. int 32 bit 
4. long 64 bit
5. float 32 bit
6. double 64 bit
7. boolean 1bit
8. char 16 bit Unicode 

在Java语言中，所有的变量在使用前必须声明

#### 5. 类变量，实例变量，局部变量

类变量：静态变量，用static关键字修饰；一个类的静态变量，所有由这类生成的对象都共用这个类变量，类装载时就分配存储空间。一个对象修改了变量，则所以对象中这个变量的值都会发生改变。

实例变量：从属于类由类生成对象时，才分配存储空间，各对象间的实例变量互不干扰，能通过对象的引用来访问实例变量

局部变量：类的方法中的变量，每次需要初始化，创建时执行，执行完销毁。

```java
public class Test{
    static int allClicks = 0; // 类变量，多为public，在方法之外
    String str = 'hi'; // 实例变量，在方法，构造方法和语句块之外
    public void method(){
        int i = 0; // 局部变量，在方法，构造方法或语句块之中
    }
}
```

数组是用来存储固定大小的同类型元素

通过值传递参数，实参的值并没有发生改变

方法重载：一个类的两个方法有相同的名字，但是有不同的参数列表

#### 6. 构造方法

**构造方法**：当一个对象被创建时候，构造方法用来**初始化该对象**。构造方法和它所在类的名字相同，但构造方法没有返回值。

当类中没有定义构造函数时，系统会指定给该类加上一个空参数的构造函数。参考https://blog.csdn.net/qq_33642117/article/details/51909346

```java
public class Dog{
    public Dog(){} // 无参的构造方法
    public Dog(String name){} //构造器仅有一个参数name
}
```

方法的可变参数的声明如下所示：

```java
typeName... parameterName
```

### 2. 面向对象

#### 2.1. 对象

创建对象需要以下三步：

- **声明**：声明一个对象，包括对象名称和对象类型。
- **实例化**：使用关键字new来创建一个对象。
- **初始化**：使用new创建对象时，会调用构造方法初始化对象。

包主要用来对类和接口进行分类

两个类在同一个包里面可以不用导入

#### 2.2 封装(Encapsulation)

封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。

普遍做法：将变量设置位private，每个值属性提供对外的公共方法访问getter,setter.要访问类中私有成员变量的类都要通过这些getter和setter方法

#### 2.3 继承

继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法。在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来

**Extends**：在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。

**implements**：使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口

**Super vs this:**

super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。

this关键字：指向自己的引用。

**final** 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：

**构造器：**子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 **super** 关键字调用父类的构造器并配以适当的参数列表

#### 2.4 重写(override)和重载(overload)

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

#### 2.5 多态

多态是同一个行为具有多个不同表现形式或形态的能力。

多态的三个必要条件

- 继承
- 重写
- 父类引用指向子类对象

多态应用：重写，接口，抽象类和方法

重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。

#### 2.6 抽象类

抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。

#### 2.7 接口(interface)

是一个抽象类型，是抽象方法的集合，接口通常以interface来声明

类描述对象的属性和方法。接口则包含类要实现的方法。





# JAVAScript

## 简介

Node.js 是JS运行环境

## 基础知识

- 我们可以使用一个 `<script>` 标签将 JavaScript 代码添加到页面中。
- `type` 和 `language` 特性（attribute）不是必需的。
- 外部的脚本可以通过 `<script src="path/to/script.js"></script>` 的方式插入。

## 代码结构

大部分时候可以省略分号，但是最好不要省略分号

现代模式 '`us strict`', **确保 “use strict” 出现在最顶部**

创建变量 `let` 旧版用 `var`

常量 `const` 需要大写硬编码

JS 是动态类型(dynamically typed) 不会限制为某一数据类型

JS 八种基本数据类型

1. number 整数和浮点数，范围 -2^53 --- 2^53 
2. bigInt 代表任意长度的整数
3. string 单双引号无区别，反引号是功能扩展。${变量名}
4. boolean: true, false
5. null 用于未知值
6. undefined 用于未定义值
7. symbol 用于唯一的标识符
8. object 复杂数据类型

我们可以通过 `typeof` 运算符查看存储在变量中的数据类型。

类型转换： 

String() 

Number() undefined--NaN, null --- 0,  

Boolean() 显示为0的都为false， 其他为true

+如果任一运算元是字符串，那么其它运算元也将被转化为字符串。

+运用于非数字，与Number()效果相同，转化为数字

++前置返回新值，后置返回旧值

== 区分不出 0 false 和空字符，需要用严格相等运算符===

aler 会弹窗，显示信息

prompt会问题，输入文本，确定

confirm 会问题，点击选择，确定

`break <labelName>` 语句跳出循环至标签处

函数

- 作为参数传递给函数的值，会被复制到函数的局部变量。
- 函数可以访问外部变量。但它只能从内到外起作用。函数外部的代码看不到函数内的局部变量。
- 函数可以返回值。如果没有返回值，则其返回的结果是 `undefined`。

函数声明 vs 函数表达式

- 如果函数在主代码流中被声明为单独的语句，则称为“函数声明”。**在函数声明被定义之前，它就可以被调用。**
- 如果该函数是作为表达式的一部分创建的，则称其“函数表达式”。**函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。**

箭头函数

```javascript
let func = (arg1, arg2, ...argN) => expression
// expression 是return
// let sum = (a, b) => a + b;
```

## 对象

```javascript
let user = new Object(); // “构造函数” 的语法
let user = {};  // “字面量” 的语法
```

添加直接赋值，删除用`delete`,最后一个属性应以逗号结尾

属性名（key）必须是字符串或 Symbol

遍历 for key in object 特殊顺序：整数属性会被进行排序，其他属性则按照创建的顺序显示。

**变量存储的不是对象本身，而是“内存中的地址”，换句话说就是对象的“引用”。**

**当对象被复制的时候 — 引用被复制了一份, 对象并没有被复制**

比较引用时，等号 `==` 和严格相等 `===` 没有差别

**两个对象只有在它们其实是一个对象时才会相等，两个独立的对象不相等，即便内容一样**

一个被 `const` 修饰的对象是 **可以** 被修改，`const`是修饰的是user本身存储的值，就是指向对象的引用，如果对象内容改变对这个没有影响

可以用`Object.assign`来复制对象，克隆出一份新的对象，合并多个对象到一个。对于更复杂的情况，用`lodash`里的函数`_.clondDeep(obj)`进行深拷贝

垃圾回收： reachability. 垃圾回收是自动完成的，回收不可达的对象

Symbol：唯一的，括号里面是描述，不会被自动转换为字符串(.toString())可以用来创建隐藏属性，加上[]，在 for in 循环中会被跳过，Object.keys(user)也会忽略，但是Object.assign会复制。

方法可以将对象引用为 `this`

构造函数在技术上是常规函数。不过有两个约定：

1. 它们的命名以大写字母开头。
2. 它们只能由 `"new"` 操作符来执行

通常构造器中没有return

## 数据类型

### 数据类型

“对象包装器”对于每种原始类型都是不同的，它们被称为 `String`、`Number`、`Boolean` 和 `Symbol`提供轻量级的临时对象。比如`str.toUpperCase()` 会创建一个轻量级的对象，调用方法然后销毁

特殊的原始类型 `null` 和 `undefined` 是例外。它们没有对应的“对象包装器”

**原始类型不是对象，不能存储额外的数据**

### 数字类型

默认的64位双精度浮点数

可以使用科学计数e

十六进制 0x  八进制0o  二进制 0b

`toString(base)` 返回在给定 `base` 进制数字系统中 `num` 的字符串表示形式。

```javascript
alert(num.toString(36)); // 一般的使用
alert( 123456..toString(36) ); // 直接在数字上使用，用两个点表示小数后面为空
```

舍入可以用 `Math.round`但是只有一位，多位使用 ：`+ num.toFixed(5)`，先返回string，再用加号转换成number

精度损失也可以用`toFixed()`来去掉不必要的小数部分

`isNaN(value)` 将其参数转换为数字，然后测试它是否为 `NaN`：

`isFinite(value)` 将其参数转换为数字，如果是常规数字，则返回 `true`，而不是 `NaN/Infinity/-Infinity`

有时候需要从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 `parseInt` 返回一个整数，而 `parseFloat` 返回一个浮点数。但必须以数字开头

**在处理小数时避免相等性检查，否则可能因为精度损失而不相等**

### 字符串

JavaScript 中的字符串使用的是 UTF-16 编码。

所有的特殊字符都以反斜杠字符 `\` 开始。它也被称为“转义字符”

`\´`插入引号，但是在双引号和反引号的string中不需要

查找子字符串，`str.indexOf(substr,pos)`

`str.includes(substr,pos)`类似的还有startsWith, endsWith

获取子字符串：`substring`、`substr` 和 `slice`。

`slice(start,end)`:返回字符串从 `start` 到（但不包括）`end` 的部分

`substring(start,end)`: slice几乎相同，允许start大于end

`substr(strat,length)`: 返回字符串从 `start` 开始的给定 `length` 的部分。

根据语言比较字符串时使用 `localeCompare`，否则将按字符代码进行比较。

`str.trim()` —— 删除字符串前后的空格 (“trims”)

`str.repeat(n)` —— 重复字符串 `n` 次





人工 自动框架 jenkins

